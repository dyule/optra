//! An engine for keeping remote siles synchronized.
//!
//! The engine is based on the Admissabilty Based Sequence Transformation algorithm (doi: [10.1109/TPDS.2010.64](http://dx.doi.org.ezproxy.library.dal.ca/10.1109/TPDS.2010.64))
//! The idea is that each site that wants to have a file synchronized will have an instance of [`Engine`](engine/struct.Engine.html) running.
//! Any changes that are made to teh file should be run through the engine using either `process_diffs()` or `process_transaction()` prior to being broadcast.
//! Any changes that are made at a remote site should be run through the engine using `integrate_remote()` prior to being applied to the file.
//!
//! This crate generally works well with [`rdiff`](https://crates.io/crates/rdiff), but can work with
//! any system that generates difference operations that are limited to insert and delete.
//!
//!# Examples
//!
//! Assuming you have a method `read_transaction` for reading transactions from remote sites,
//! the process for integrating remote changes onto a local file go like this:
//!
//! ```no_run
//!# use optra::{Engine, TransactionSequence};
//!# use std::collections::LinkedList;
//!# fn read_transaction() -> TransactionSequence {
//!#       TransactionSequence::new(None, 2, LinkedList::new(), LinkedList::new())
//!# }
//!#
//!# let mut engine = Engine::new(1);
//! let mut remote_sequence = read_transaction();
//! engine.integrate_remote(&mut remote_sequence);
//! remote_sequence.apply("local_file").unwrap();
//! ```
//!
//! On the other hand, if you have a Diff generated by detecting differences to a local file,
//! you can process the diff and then send it out (assuming you have a method called `send_transaction()`)
//!
//! ```no_run
//!# extern crate rdiff;
//!# extern crate optra;
//!# use optra::{Engine, TransactionSequence};
//!# use rdiff::BlockHashes;
//!# use std::collections::LinkedList;
//!# use std::fs::File;
//!# fn main() {
//!# fn send_transaction(_seq: TransactionSequence) {
//!#
//!# }
//!#
//!# let mut engine = Engine::new(1);
//!# let mut file_hashes = BlockHashes::new(File::open("local_file").unwrap(), 8).unwrap();
//! let diffs = file_hashes.diff_and_update(File::open("local_file").unwrap()).unwrap();
//! let transaction = engine.process_diffs(diffs);
//! send_transaction(transaction);
//!# }
//! ```
#![feature(custom_derive, plugin, linked_list_extras)]
#![plugin(serde_macros)]
#![deny(missing_docs)]
extern crate serde;
extern crate serde_json;
#[macro_use]
extern crate log;
extern crate rdiff;

mod operations;
mod utils;
mod engine;

pub use operations::{InsertOperation, DeleteOperation, Operation, State};

pub use engine::{Engine, TransactionSequence};

type Offset = i64;
type Position = u64;

/// Represents an error in attempting to synchronize remote operations
#[derive(Debug)]
pub struct OTError {
    /// The kind of error this is
    pub kind: ErrorKind
}

/// Represents the kind of error we encountered synchronizing operations
#[derive(Debug)]
pub enum ErrorKind {
    /// The remote operations refer to a state that we have not yet recieved
    NoSuchState
}


impl OTError {
    /// Create a new OTError of the given kind.
    #[inline]
    pub fn new(kind: ErrorKind) -> OTError {
        OTError {
            kind: kind
        }
    }
}
