use std::collections::LinkedList;
use std::cmp::Ordering;
use std::result::Result as StdResult;
use operations::{State, Operation, InsertOperation, DeleteOperation};
use ::{OTError, ErrorKind as Kind, Position};

pub type Result<T> = StdResult<T, OTError>;

pub struct Engine {
    /// The unique ID for this site
    site_id: u32,

    /// The state of the most recently applied operation,
    /// or none if no operations have been applied
    last_state: Option<State>,

    /// The inserts for this site, stored in effect order
    inserts: LinkedList<InsertOperation>,

    /// The deletes for this site, stored in effect order
    deletes: LinkedList<DeleteOperation>,

    /// The timestamp for operations that have already been integrated into the history
    time_stamp: u32
}

pub struct TransactionSequence {
    /// The state that this sequence started with
    starting_state: State,

    /// The inserts for this sequence, stored in effect order
    inserts: LinkedList<InsertOperation>,

    /// The deletes for this sequence, stored in effect order
    deletes: LinkedList<DeleteOperation>,
}

// Public methods
impl Engine {
    #[inline]
    /// Creates a new engine for the given site id.  The id should be
    /// unique across all clients, and probably generated by the server
    pub fn new(site_id: u32) -> Engine {
        Engine {
            site_id: site_id,
            last_state: None,
            inserts: LinkedList::new(),
            deletes: LinkedList::new(),
            time_stamp: 0
        }
    }

    /// Integrates the sequence of operations given by `remote_sequence` into the local history.  The ordering
    /// properties of the local history will be maintained, and a sequence of operations that
    /// can be applied to the local state will be returned.
    pub fn integrate_remote(&mut self, remote_sequence: &mut TransactionSequence) -> StdResult<(), OTError> {

        //Get all the local inserts that have happened since the last sync with the remote site
        let local_concurrent_inserts = try!(self.get_concurrent_inserts(&remote_sequence.starting_state));
        // Transform the remote inserts so that they account for the changes from the local inserts
        Engine::transform(&mut remote_sequence.inserts, &local_concurrent_inserts);

        // Save the inserts as they are before integrating the local deletes, since that will be
        // used later for integrating the remote deletes
        let mut transformed_remote_inserts = remote_sequence.inserts.clone();

        // Transform the remote inserts so that they account for the changes from the local deletes
        Engine::transform(&mut remote_sequence.inserts, &self.deletes);

        self.assign_timestamps(&mut transformed_remote_inserts);

        // Merge the transformed remote inserts with the local.  Note that we use the inserts that have not been
        // transformed by deletes, as the local inserts always preceded the deletes.
        Engine::merge_sequences(&mut self.inserts, &transformed_remote_inserts);

        // Adjust the local deletes with the remote inserts that have been merged into the local inserts
        Engine::transform(&mut self.deletes, &transformed_remote_inserts);

        // Transform the remote deletes with all of the local inserts that happened since the last sync
        Engine::transform(&mut remote_sequence.deletes, &local_concurrent_inserts);

        // Transform the remote deletes with ALL of the local deletes.
        Engine::transform(&mut remote_sequence.deletes, &self.deletes);

        self.assign_timestamps(&mut remote_sequence.deletes);

        // Merge the remote deletes that have taken all the local operations into effect with the local deletes
         Engine::merge_sequences(&mut self.deletes, &mut remote_sequence.deletes);

         Ok(())

    }
}

// Private methods
impl Engine {
    fn get_concurrent_inserts(&self, starting_state: &State) -> Result<LinkedList<InsertOperation>> {

        let reference_time = match self.inserts.iter().find(|o| o.get_state().matches(starting_state)) {
            Some(ref o) => o.get_state().get_time(),
            None => {
                match self.deletes.iter().find(|o| o.get_state().matches(starting_state)) {
                    Some(ref o) => o.get_state().get_time(),
                    None => return Err(OTError::new(Kind::NoSuchState))
                }
            }
        };

        Ok(self.inserts.iter().filter(|o| o.get_state().happened_after(reference_time)).map(|o| o.clone()).collect())

    }

    fn assign_timestamps<O: Operation>(&mut self, sequence: &mut LinkedList<O>) {
        for o in sequence {
            self.time_stamp += 1;
            o.get_state_mut().set_time(self.time_stamp);
        }
    }

    fn transform<O1: Operation, O2: Operation>(incoming_sequence: &mut LinkedList<O1>, existing_sequence: &LinkedList<O2>)  {
        // let mut incoming_offset = 0;
        // let mut existing_offset = 0;
        // let mut incoming_iter = incoming_sequence.iter_mut();
        // let mut existing_iter = existing_sequence.iter();
        // let mut incoming_op = incoming_iter.next();
        // let mut existing_op = existing_iter.next();
        // let mut size_delta = 0;
        // let mut position_delta = 0;
        // println!("Loop Starting");
        // loop {
        //     let advance_incoming = if let Some(existing_op) = existing_op {
        //          if let Some(ref mut incoming_op) = incoming_op {
        //              println!("Before update: Incoming: ({:2}, {:2}) : {:2}, Existing: ({:2}, {:2}) : {:2} - {:2}", incoming_op.get_position(), -incoming_op.get_increment(), incoming_offset,  existing_op.get_position(), -existing_op.get_increment(), existing_offset, size_delta);
        //              let (size_change, position_change) = incoming_op.resolve_overlap(existing_op, incoming_offset - size_delta, existing_offset);
        //              size_delta += size_change;
        //              position_delta += position_change;
        //             if incoming_op.compare_with_offsets(existing_op, incoming_offset, existing_offset) {
        //                 incoming_op.update_position_by(existing_offset + size_delta - size_change + position_delta);
        //                 //incoming_offset -= change;
        //                 position_delta = 0;
        //                 println!(">After update: *Incoming: ({:2}, {:2}) : {:2}, Existing: ({:2}, {:2}) : {:2} - {:2}", incoming_op.get_position(), -incoming_op.get_increment(), incoming_offset,  existing_op.get_position(), -existing_op.get_increment(), existing_offset, size_delta);
        //                 true
        //             } else {
        //                 println!(">After update: Incoming: ({:2}, {:2}) : {:2}, *Existing: ({:2}, {:2}) : {:2} - {:2}", incoming_op.get_position(), -incoming_op.get_increment(), incoming_offset,  existing_op.get_position(), -existing_op.get_increment(), existing_offset, size_delta);
        //                 false
        //             }
        //         } else {
        //             false
        //         }
        //     } else{
        //         if let Some(ref mut incoming_op) = incoming_op {
        //             incoming_op.update_position_by(existing_offset + size_delta + position_delta);
        //             position_delta = 0;
        //             true
        //         } else {
        //             break;
        //         }
        //     };
        //     if advance_incoming {
        //         incoming_offset += incoming_op.unwrap().get_increment();
        //         incoming_op = incoming_iter.next();
        //     } else {
        //         existing_offset += existing_op.unwrap().get_increment();
        //         existing_op = existing_iter.next();
        //     }
        //
        //
        // }
        // while let Some(existing_op) = existing_iter.next() {
        //     loop {
        //         if let Some(ref mut incoming_op) = incoming_op {
        //             trace!("Existing: {:?}, Offset: {:?}. Incoming: {:?}, Offset: {:?}", existing_op, existing_offset, incoming_op, incoming_offset);
        //             if !incoming_op.compare_with_offsets(existing_op, incoming_offset, existing_offset) {
        //                 let change = incoming_op.resolve_overlap(existing_op, incoming_offset, existing_offset);
        //                 incoming_offset += change;
        //                 delta += change;
        //                 debug!("Change before break: {}", change);
        //                 break
        //             }
        //             let change = incoming_op.resolve_overlap(existing_op, incoming_offset, existing_offset);
        //             incoming_op.update_position_by(existing_offset + delta);
        //             incoming_offset += change;
        //             delta += change;
        //             debug!("Change during loop: {}", change);
        //             incoming_offset += incoming_op.get_increment();
        //         } else {
        //             break
        //         }
        //         trace!("Next incoming operation");
        //         incoming_op = incoming_iter.next()
        //     }
        //     existing_offset += existing_op.get_increment();
        //     trace!("Next existing operation");
        // }
        // loop {
        //     if let Some(ref mut incoming_op) = incoming_op {
        //         incoming_op.update_position_by(existing_offset + delta);
        //     } else {
        //         break;
        //     }
        //     incoming_op = incoming_iter.next()
        // }
    }


    fn merge_sequences<A: Ord + Clone>(seq1: &mut LinkedList<A>, seq2: &LinkedList<A>) {
        fn something_less<A: Ord + Clone>(a: Option<&mut A>, b: &A) -> bool {
            match a {
                Some(ref a) => {
                    (**a).cmp(&b) == Ordering::Less
                }, None => {
                    false
                }
            }
        }
        let mut seq1_iter = seq1.iter_mut();
        let mut seq2_iter = seq2.iter();
        while let Some(elem2) = seq2_iter.next() {
            while something_less(seq1_iter.peek_next(), &elem2) {
                seq1_iter.next();
            }
            seq1_iter.insert_next(elem2.clone());
        }
    }

}



#[cfg(test)]
mod tests {
    use super::{Engine};
    use std::collections::LinkedList;
    use operations::{InsertOperation, DeleteOperation, State, Operation};
    use ::{Position};
    extern crate env_logger;

    macro_rules! create_list {
        ( $( $x:expr ),* ) => {
            {
                vec![$($x,)*].into_iter().collect::<LinkedList<_> >()
            }
        };
    }

    fn generate_insert_list(operation_details: Vec<(Position, &'static str)>, site_id: u32) -> LinkedList<InsertOperation> {
        let mut the_list = LinkedList::new();
        let mut time_stamp = 0;
        for (position, value) in operation_details {
            the_list.push_back(InsertOperation::new(position, value.bytes().collect(), State::new(site_id, time_stamp, time_stamp)));
            time_stamp += 1;
        }
        the_list
    }

    fn generate_delete_list(operation_details: Vec<(Position, Position)>, site_id: u32) -> LinkedList<DeleteOperation> {
        let mut the_list = LinkedList::new();
        let mut time_stamp = 0;
        for (position, length) in operation_details {
            the_list.push_back(DeleteOperation::new(position, length, State::new(site_id, time_stamp, time_stamp)));
            time_stamp += 1;
        }
        the_list
    }

    fn to_insert_tuple_vec<'a>(list: &'a LinkedList<InsertOperation>) -> Vec<(Position, &'a str)> {
        use std::str;
        list.iter().map(|op| {
            (op.get_position(), unsafe {str::from_utf8_unchecked(&op.get_value())})
        }).collect()
    }

    fn to_delete_tuple_vec<'a>(list: &'a LinkedList<DeleteOperation>) -> Vec<(Position, Position)> {
        list.iter().map(|op| {
            (op.get_position(), op.get_length())
        }).collect()
    }

    #[test]
    fn merging_sequences() {
        let mut list1:LinkedList<_> = create_list![2, 5, 8, 12, 34, 89];
        let list2:LinkedList<_> = create_list![5, 7, 9, 11, 45, 67];

        Engine::merge_sequences(&mut list1, &list2);
        assert_eq!(list1, create_list![2, 5, 5, 7, 8, 9, 11, 12, 34, 45, 67, 89]);
        assert_eq!(list2, create_list![5, 7, 9, 11, 45, 67]);

        Engine::merge_sequences(&mut list1, &LinkedList::new());
        assert_eq!(list1, create_list![2, 5, 5, 7, 8, 9, 11, 12, 34, 45, 67, 89]);

        let mut empty_list = LinkedList::new();
        Engine::merge_sequences(&mut empty_list, &mut list1);
        assert_eq!(list1, create_list![2, 5, 5, 7, 8, 9, 11, 12, 34, 45, 67, 89]);
        assert_eq!(empty_list, create_list![2, 5, 5, 7, 8, 9, 11, 12, 34, 45, 67, 89]);

    }

//     #[test]
//     fn test_transform_insert_insert() {
//         // Starting with the buffer "The quick brown fox"
//         let mut sequence1 = generate_insert_list(vec![
//             // Add an "ee" after "the"
//             (3, "ee"),
//             // Add another "k" on the end of "quick"
//             (11, "k"),
//             // Add "wnwnwn" to the end of "brown"
//             (18, "wnwnwn"),
//             // Add "xx!" to the end of "fox"
//             (28, "xx!")
//         ], 2);
//         // After sequence1 is applied, we would have "Theee quickk brownwnwnwn foxxx!"
//         let sequence2 = generate_insert_list(vec![
//             // insert "very " after "the"
//             (4, "very "),
//             // insert "ly" after "quick"
//             (14, "ly"),
//             // insert "u" after the 'o' in "brown"
//             (20, "u"),
//         ], 1);
//         Engine::transform(&mut sequence1, &sequence2);
//         // After sequence2 is applied, we would have "The very quickly brouwn fox"
//         assert_eq!(to_insert_tuple_vec(&sequence1), vec![
//             // Add an "ee" after "the"
//             (3, "ee"),
//             // Add another "k" on the end of "quickly"
//             (18, "k"),
//             // Add "wnwnwn" to the end of "brouwn"
//             (26, "wnwnwn"),
//             // Add "xx!" to the end of "fox"
//             (36, "xx!"),
//         ]);
//         // If sequence 2 is applied after sequence 1, we would have "Theee very quicklyk brouwnwnwnwn foxxx!"
//     }
//
//     #[test]
//     fn test_transform_delete_insert(){
//         // Starting with the buffer "The very quickly brouwn fox"
//         let mut sequence1 = generate_delete_list(vec![
//             // delete the "e" from "the"
//             (2, 1),
//             // delete the "e" from "very"
//             (4, 1),
//             // delete the "ui" from "quickly"
//             (8, 2),
//             // delete the "ou" from "brouwn"
//             (15, 2),
//             // delete the "o" from "fox"
//             (19, 1),
//         ], 1);
//         // after sequence1 is applied, we would have "Th vry qckly brwn fx"
//         let sequence2 = generate_insert_list(vec![
//             // Add an "ee" after "the"
//             (3, "ee"),
//             // Add another "k" on the end of "quickly"
//             (18, "k"),
//             // Add "wnwnwn" to the end of "brouwn"
//             (26, "wnwnwn"),
//             // Add "xx!" to the end of "fox"
//             (36, "xx!"),
//         ], 2);
//         // After sequence2 is applied, we will have "Theee very quicklyk brouwnwnwnwn foxxx!"
//         Engine::transform(&mut sequence1, &sequence2);
//         assert_eq!(to_delete_tuple_vec(&sequence1), vec![
//             // delete the first "e" from "theee"
//             (2, 1),
//             // delete the "e" from "very"
//             (6, 1),
//             // delete the "ui" from "quicklyk"
//             (10, 2),
//             // delete the "ou" from "brouwnwnwnwn"
//             (18, 2),
//             // delete the "o" from "foxxx!"
//             (28, 1),
//         ]);
//         // After running sequence1 then sequence2, we get "Thee vry qcklyk brwnwnwnwn fxxx!"
//     }
//     #[test]
//     fn test_transform_delete_delete() {
//         let _ = env_logger::init();
//       // Starting with buffer "The quick brown fox jumped over the lazy dog"
//       let sequence1 =  generate_delete_list(vec![
//           // Delete "quick bro"
//           (4, 9),
//           // Delete "ed over"
//           (15, 7),
//           // Delete "laz"
//           (20, 3),
//       ], 2);
//       // After sequence1 is applied, we will have "The wn fox jump the y dog"
//       let mut sequence2 =  generate_delete_list(vec![
//           // Delete "he qu"
//           (1, 5),
//           // Delete "ck"
//           (2, 2),
//           // Delete "rown"
//           (4, 4),
//           // Delete "the lazy dog"
//           (21, 12),
//       ], 1);
//       // After sequence2 is applied, we will have "Ti b fox jumped over"
//       let mut seq1_prime = sequence1.clone();
//       Engine::transform(&mut seq1_prime, &sequence2);
//       assert_eq!(to_delete_tuple_vec(&seq1_prime), vec![
//           // Delete "i b"
//           (1, 3),
//           // Delete "ed over"
//           (10, 7),
//           // Delete "" (was "laz")
//           (20, 0),
//       ]);
//       Engine::transform(&mut sequence2, &sequence1);
//       assert_eq!(to_delete_tuple_vec(&sequence2), vec![
//           // Delete "he "
//           (1, 3),
//           // Delete ""
//           (1, 0),
//           // Delete "wn"
//           (1, 2),
//           // Delete "the "
//           (11, 4),
//           // Delete "y dog"
//           (11, 5),
//       ]);
//   }
//
//   #[test]
//   fn test_transform_delete_delete_with_0_length_deletes() {
//       // Starting with buffer "The quick brown fox jumped over the lazy dog"
//       let sequence1 = generate_delete_list(vec![
//           // Delete "h"
//           (1, 1),
//           // Delete "" after "T"
//           (1, 0),
//           // Delete "ck "
//           (6, 3),
//           // Delete "" after "n"
//           (11, 0),
//       ], 2);
//       // After sequence1 is applied, we will have "Te quibrown fox jumped over the lazy dog"
//       let mut sequence2 = generate_delete_list(vec![
//           // Delete "e"
//           (2, 1),
//           // Delete "c"
//           (6, 1),
//           // Delete "ow"
//           (10, 2),
//           // Delete "mp"
//           (18, 2),
//           // Detete " " after "the
//           (29, 1),
//       ], 1);
//       // After sequence2 is applied, we will have "Th quik brn fox jued over thelazy dog"
//       Engine::transform(&mut sequence2, &sequence1);
//       assert_eq!(to_delete_tuple_vec(&sequence2), vec![
//           // Delete "e"
//           (1, 1),
//           // Delete "" (was delete "c")
//           (5, 0),
//           // Delete "ow"
//           (7, 2),
//           // Delete "mp"
//           (15, 2),
//           // Delete " " after "the"
//           (26, 1),
//       ]);
//       // After both have been applied, we will have "T quibrn fox jued over thelazy dog"
//   }
//
//   #[test]
//   fn test_transform_delete_delete_simple() {
//       // starting with buffer "The quick brown fox jumped over the lazy dog"
//       let sequence1 =  generate_delete_list(vec![
//           // Delete "The"
//           (0, 3),
//           // Delete "brown"
//           (7, 5),
//           // Delete "jumped"
//           (12, 6),
//           // Delete "the"
//           (18, 3),
//           // Delete "dog"
//           (24, 3),
//       ], 1);
//       // After these operations run, we will have " quick  fox  over  lazy "
//       let mut sequence2 =  generate_delete_list(vec![
//           // Delete "quick"
//           (4, 5),
//           // Delete "fox"
//           (11, 3),
//           // Delete "over"
//           (19, 4),
//           // Delete "lazy"
//           (24, 4),
//       ], 2);
//       // After these operations, we will have "The  brown  jumped  the  dog"
//       let mut seq1_prime = sequence1.clone();
//       Engine::transform(&mut seq1_prime, &sequence2);
//       assert_eq!(to_delete_tuple_vec(&seq1_prime), vec![
//           // Delete "The"
//           (0, 3),
//           // Delete "brown"
//           (2, 5),
//           // Delete "jumped"
//           (4, 6),
//           // Delete "the"
//           (6, 3),
//           // Delete "dog"
//           (8, 3),
//       ]);
//
//       Engine::transform(&mut sequence2, &sequence1);
//       assert_eq!(to_delete_tuple_vec(&sequence2), vec![
//           // Delete "quick"
//           (1, 5),
//           // Delete "fox"
//           (3, 3),
//           // Delete "over"
//           (5, 4),
//           // Delete "lazy"
//           (7, 4),
//       ]);
//   }
//
}
